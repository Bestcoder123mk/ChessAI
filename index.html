<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI</title>

    <!-- Local Dependencies -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #e0eafc, #cfdef3);
            color: #333;
            padding: 20px;
        }

        h2 {
            color: #007BFF;
            font-size: 24px;
            margin-bottom: 10px;
        }

#board-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 20px;
    margin: 20px auto;
    max-width: 1000px; /* Adjusted for better spacing */
}

#info {
    order: -1; /* Moves the info div to the left */
    width: 300px;
    padding: 15px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    text-align: center;
}


#board {
    width: 400px;
    height: 400px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    background-color: #fff;
    padding: 10px;
}


        #move-history {
            width: 150px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            max-height: 400px;
            overflow-y: auto;
        }

        button {
            padding: 12px 15px;
            margin: 8px;
            border: none;
            background: linear-gradient(90deg, #007BFF, #0056b3);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease-in-out;
        }

        button:hover {
            background: linear-gradient(90deg, #0056b3, #004494);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        input, select {
            padding: 10px;
            margin: 8px;
            border-radius: 6px;
            border: 1px solid #bbb;
            font-size: 14px;
            width: 250px;
            text-align: center;
        }

        #gameStatus {
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
        }

        #gameStatus:empty {
            display: none;
        }
        @media (max-width: 600px) {
            #board-container {
                flex-direction: column;
                align-items: center;
            }

            #board {
                width: 300px;
                height: 300px;
            }

            #move-history {
                width: 100%;
                max-height: 200px;
            }

            button {
                font-size: 14px;
                padding: 10px;
            }

            input, select {
                width: 200px;
            }
        }
        .square-55d63 {
    transition: background-color 0.2s ease-in-out;
    }

    </style>
</head>
<body>
    <h2>Chess AI</h2>
<div id="board-container">
    <div id="info">
        <button id="bestMoveBtn">Find Best Move</button>
        <p id="best-move">Best Move: -</p>
        <input type="text" id="username" placeholder="Enter Chess.com Username">
        <button onclick="fetchPlayerData()" id="statsBtn">Get Player Stats</button>
        <p id="player-stats">Player Stats: -</p>
        <h3>Past Games</h3>
        <select id="game-history">
            <option value="">Select a game</option>
        </select>
        <button id="analyzeGame">Analyze Game</button>
        <p id="move-analysis">Move Analysis: -</p>
    </div>

    <div id="board"></div>

    <div id="move-history">
        <h3>Move History</h3>
        <ul id="move-list"></ul>
    </div>
</div>
    <button id="gamestartBtn">Play With A Computer</button>
    <p id="gameStatus" style="font-size: 18px; font-weight: bold; color: red;"></p>
    <button id="restartBtn">Restart Game</button>
    <button id="startBtn">Start Position</button>
    <button id="clearBtn">Clear Board</button>
    <script>
        let board, game, moves, currentMoveIndex, selectedSquare;

document.addEventListener("DOMContentLoaded", () => {
    game = new Chess();

    function onDrop(source, target) {
        if (stopAI) return; // Allow manual play without AI interference
        var move = game.move({ from: source, to: target, promotion: 'q' });
        if (move === null) return 'snapback';
        updateMoveHistory();
        checkGameStatus();
        if (!game.game_over()) setTimeout(makeBestMove, 500); // AI move with delay
    }

    function onSquareClick(square) {
        if (selectedSquare) {
            // Attempt move
            let move = game.move({ from: selectedSquare, to: square, promotion: 'q' });

            if (move === null) {
                selectedSquare = null;
                removeHighlighting();
                return;
            }

            board.position(game.fen());
            updateMoveHistory();
            removeHighlighting();
            selectedSquare = null;

            setTimeout(makeBestMove, 500); // AI Move
        } else {
            // Select piece
            if (game.get(square)) {
                selectedSquare = square;
                highlightSquare(square, "highlight");

                // Highlight possible moves
                let moves = game.moves({ square: square, verbose: true });
                moves.forEach(m => highlightSquare(m.to, "move-highlight"));
            }
        }
    }

    function onSnapEnd() {
        board.position(game.fen());
    }

    function onMouseoverSquare(square) {
        const moves = game.moves({ square: square, verbose: true });
        if (moves.length === 0) return;
        highlightSquare(square, "rgba(255, 255, 0, 0.6)"); // Highlight selected square
        moves.forEach(move => highlightSquare(move.to, "rgba(0, 255, 0, 0.6)")); // Highlight legal moves
    }

    function onMouseoutSquare() {
        removeHighlighting();
    }

    // Initialize Chessboard
    board = Chessboard('board', {
        draggable: true,
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        onMouseoverSquare: onMouseoverSquare,
        onMouseoutSquare: onMouseoutSquare,
        onSquareClick: onSquareClick
    });

    console.log("Chessboard initialized successfully!"); // Debugging log
});


        document.getElementById("startBtn").addEventListener("click", () => {
            game.reset();
            board.position('start');
            updateMoveHistory();
        });
        
        document.getElementById("clearBtn").addEventListener("click", () => {
            game.clear();
            board.position('empty');
            updateMoveHistory();
        });

        document.getElementById("bestMoveBtn").addEventListener("click", analyzeWithStockfish);
        document.getElementById("gamestartBtn").addEventListener("click", play);
        
        async function analyzeWithStockfish() {
            const fen = game.fen();
            const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to get analysis");

                const data = await response.json();
                if (data.success && data.bestmove) {
                    const bestMove = data.bestmove.split(" ")[1]; // Extract best move (e.g., "b7b6")

                    if (bestMove.length === 4) {
                        const fromSquare = bestMove.substring(0, 2);
                        const toSquare = bestMove.substring(2, 4);

                        // Highlight squares on the board
                        highlightMove(fromSquare, toSquare);
                    }

                    document.getElementById("best-move").innerText = `Best Move: ${bestMove} (Eval: ${data.evaluation})`;
                } else {
                    document.getElementById("best-move").innerText = "Best Move: No data available";
                }
            } catch (error) {
                console.error("Error analyzing position:", error);
                document.getElementById("best-move").innerText = "Best Move: Error fetching move";
            }
        }

        function highlightMove(from, to) {
            // Remove previous highlights
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));

            // Add new highlights
            document.querySelector(`.square-${from}`).classList.add('highlight');
            document.querySelector(`.square-${to}`).classList.add('highlight');
        }

        const style = document.createElement('style');
        style.innerHTML = `
            .highlight {
                background-color: 	rgb(0, 255, 255) !important; 
            }
        `;
        document.head.appendChild(style);

        async function fetchPlayerData() {
            const username = document.getElementById("username").value.trim();
            if (!username) {
                alert("Please enter a Chess.com username");
                return;
            }
            
            try {
                const statsResponse = await fetch(`https://api.chess.com/pub/player/${username}/stats`);
                if (!statsResponse.ok) throw new Error("Player not found");
                const statsData = await statsResponse.json();

                document.getElementById("player-stats").innerText = 
                    `Blitz: ${statsData.chess_blitz?.last?.rating || "N/A"}, ` +
                    `Bullet: ${statsData.chess_bullet?.last?.rating || "N/A"}, ` +
                    `Rapid: ${statsData.chess_rapid?.last?.rating || "N/A"}`;

                await getPlayerGames(username);
            } catch (error) {
                console.error("Error fetching player data:", error);
                document.getElementById("player-stats").innerText = "Player Stats: Error fetching data";
            }
        }

        async function getPlayerGames(username) {
            try {
                const response = await fetch(`https://api.chess.com/pub/player/${username}/games/archives`);
                if (!response.ok) throw new Error("Games not found");
                const archives = await response.json();
                
                const latestArchiveUrl = archives.archives.pop();
                const gameResponse = await fetch(latestArchiveUrl);
                if (!gameResponse.ok) throw new Error("Games not found");
                const gameData = await gameResponse.json();

                const select = document.getElementById("game-history");
                select.innerHTML = '<option value="">Select a game</option>';
                
                gameData.games.forEach(game => {
                    if (game.pgn) {
                        const option = document.createElement("option");
                        option.value = game.pgn;
                        option.textContent = new Date(game.end_time * 1000).toLocaleString();
                        select.appendChild(option);
                    }
                });
            } catch (error) {
                console.error("Error fetching games:", error);
            }
        }

        document.getElementById("analyzeGame").addEventListener("click", analyzeSelectedGame);

        function analyzeSelectedGame() {
            const selectedGamePGN = document.getElementById("game-history").value;
            if (!selectedGamePGN) {
                alert("Please select a game to analyze!");
                return;
            }

            game.load_pgn(selectedGamePGN);
            moves = game.history({ verbose: true });
            currentMoveIndex = 0;
            board.position(game.fen());

            document.getElementById("best-move").innerText = "Best Move: -";
            createNavigationButtons();
        }

        function createNavigationButtons() {
            let controls = document.getElementById("info");

            if (!document.getElementById("prevMoveBtn")) {
                let prevBtn = document.createElement("button");
                prevBtn.id = "prevMoveBtn";
                prevBtn.innerText = "Previous Move";
                prevBtn.onclick = () => navigateMoves(-1);
                controls.appendChild(prevBtn);
            }

            if (!document.getElementById("nextMoveBtn")) {
                let nextBtn = document.createElement("button");
                nextBtn.id = "nextMoveBtn";
                nextBtn.innerText = "Next Move";
                nextBtn.onclick = () => navigateMoves(1);
                controls.appendChild(nextBtn);
            }
        }

        async function analyzeCurrentMove() {
    const fen = game.fen();
    const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to get analysis");

        const data = await response.json();
        console.log("Stockfish API Response:", data);

        if (!data.success || !data.bestmove) {
            console.error("Stockfish did not return a valid best move.");
            document.getElementById("move-analysis").innerText = "No analysis available";
            return;
        }

        const bestMove = data.bestmove.split(" ")[1] || "N/A"; // Extract Stockfish's best move
        const evalScore = parseFloat(data.evaluation || "0"); // Ensure evaluation is a number

        console.log(`Best Move: ${bestMove}, Evaluation: ${evalScore}`); // Debugging logs

        // Get the player's move
        const playerMove = moves[currentMoveIndex - 1]?.san || "None";

        // Calculate material difference before and after the move
        const materialBefore = calculateMaterial(game.fen());
        game.undo(); // Undo the last move to check the previous position
        const materialAfter = calculateMaterial(game.fen());
        game.move(playerMove); // Redo the move

        const materialDifference = materialAfter - materialBefore;

        // Chess.com-style Move Categorization
        let moveCategory = "Good Move"; // Default label
        let moveColor = "black"; // Default color

        // Thresholds for move categorization
        const evalThresholds = {
            brilliant: 2.5, // Sacrifice & best move
            great: 2.0, // Best move but not a sacrifice
            book: 0.0, // Opening moves
            inaccuracy: 0.8, // Small mistake
            mistake: 1.5, // Medium mistake
            blunder: 3.0 // Huge mistake
        };

        // Check if the move is the best move
        const isBestMove = playerMove === bestMove;

        // Check if the move involves a sacrifice
        const isSacrifice = materialDifference < 0; // Material is lost

        // Check if the move leads to a significant improvement in evaluation
        const isSignificantImprovement = Math.abs(evalScore) > evalThresholds.brilliant;

        // Determine if the move is "Brilliant"
        if (isBestMove && isSacrifice && isSignificantImprovement) {
            moveCategory = "Brilliant Move";
            moveColor = "cyan";
        } else if (isBestMove && Math.abs(evalScore) > evalThresholds.great) {
            moveCategory = "Great Move";
            moveColor = "indigo";
        } else if (isBestMove) {
            moveCategory = "Best Move";
            moveColor = "green";
        } else if (Math.abs(evalScore) <= evalThresholds.book) {
            moveCategory = "Book Move";
            moveColor = "gray";
        } else if (Math.abs(evalScore) > evalThresholds.inaccuracy && Math.abs(evalScore) < evalThresholds.mistake) {
            moveCategory = "Inaccuracy";
            moveColor = "#FFCE1B";
        } else if (Math.abs(evalScore) > evalThresholds.mistake && Math.abs(evalScore) < evalThresholds.blunder) {
            moveCategory = "Mistake";
            moveColor = "orange";
        } else if (Math.abs(evalScore) > evalThresholds.blunder) {
            moveCategory = "Blunder";
            moveColor = "red";
        }

        // Display Move Analysis
        const moveInfo = document.getElementById("move-analysis");
        moveInfo.innerHTML = `<strong>${moveCategory}:</strong> ${playerMove} <br> 
                              Stockfish Suggestion: <strong>${bestMove}</strong> <br> 
                              Eval: <strong>${evalScore}</strong>`;
        moveInfo.style.color = moveColor;

    } catch (error) {
        console.error("Error analyzing position:", error);
        document.getElementById("move-analysis").innerText = "Error fetching move data";
    }
}

// Helper function to calculate material difference
function calculateMaterial(fen) {
    const pieceValues = {
        p: 1, n: 3, b: 3, r: 5, q: 9, k: 0, // Pawn, Knight, Bishop, Rook, Queen, King
        P: -1, N: -3, B: -3, R: -5, Q: -9, K: 0
    };

    let material = 0;
    for (let char of fen.split(" ")[0]) {
        if (pieceValues[char]) {
            material += pieceValues[char];
        }
    }
    return material;
}
function updateMoveHistory() {
    const moveList = document.getElementById("move-list");
    moveList.innerHTML = ""; // Clear previous moves

    const history = game.history();
    history.forEach((move, index) => {
        const li = document.createElement("li");
        li.textContent = `${index + 1}. ${move}`;
        moveList.appendChild(li);
    });
}
let stopAI = false; // Flag to control AI play

function play() { 
    stopAI = false; // Ensure AI is enabled when Play is pressed
    game.reset();
    board.position('start');

    function onDrop(source, target) {
        if (stopAI) return; // Allow manual play without AI interference

        var move = game.move({ from: source, to: target, promotion: 'q' });

        if (move === null) return 'snapback'; // Invalid move

        updateMoveHistory();
        checkGameStatus();

        // AI moves only if it's Black's turn
        if (!game.game_over() && game.turn() === 'b') {
            setTimeout(makeBestMove, 500); 
        }
    }

    async function makeBestMove() {
    if (game.game_over() || stopAI || game.turn() === 'w') return; // Stop AI if disabled or not its turn

    const fen = game.fen();
    const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to get AI move");

        const data = await response.json();
        console.log("Stockfish API Response:", data); // ðŸ”¥ Log AI move response

        if (data.success && data.bestmove) {
            const bestMove = data.bestmove.split(" ")[1]; // Extract best move (e.g., "e2e4")
            console.log("AI Best Move:", bestMove); // ðŸ”¥ Log AI chosen move

            // Convert UCI move to an object Chess.js understands
            const moveObj = {
                from: bestMove.substring(0, 2),
                to: bestMove.substring(2, 4),
                promotion: "q" // Assume queen promotion by default
            };

            const move = game.move(moveObj);
            if (!move) {
                console.error("AI move was invalid:", moveObj);
                return;
            }

            console.log("Move successfully made:", move); // ðŸ”¥ Log successful AI move

            board.position(game.fen()); // âœ… Update board
            updateMoveHistory();
            checkGameStatus();

            // âœ… Now highlight AI's move
            highlightMove(move.from, move.to);

            // AI moves again if it's still Black's turn (AI vs AI)
            if (!game.game_over() && game.turn() === 'b') {
                setTimeout(makeBestMove, 500);
            }
        } else {
            console.error("Stockfish did not return a valid move.");
        }
    } catch (error) {
        console.error("Error making AI move:", error);
    }
}



    function onSnapEnd() {
        board.position(game.fen());
    }

    function checkGameStatus() {
        const statusElement = document.getElementById("gameStatus");

        if (game.in_checkmate()) {
            let winner = game.turn() === 'w' ? 'Black' : 'White';
            statusElement.innerText = `Checkmate! ${winner} Wins!`;
        } else if (game.in_draw()) {
            statusElement.innerText = "It's a Draw!";
        } else {
            statusElement.innerText = "";
        }
    }

    function onMouseoverSquare(square) {
        if (game.game_over()) return;
        const moves = game.moves({ square: square, verbose: true });
        if (moves.length === 0) return;

        highlightSquare(square, "rgba(255, 255, 0, 0.6)"); // Highlight selected square
        moves.forEach(move => highlightSquare(move.to, "rgba(0, 255, 0, 0.6)")); // Highlight legal moves
    }

    function onMouseoutSquare() {
        removeHighlighting();
    }

    function highlightMove(from, to) {
        removeHighlighting();
        highlightSquare(from, "rgba(255, 255, 0, 0.6)"); // Yellow for AI's from-square
        highlightSquare(to, "rgba(0, 255, 0, 0.6)"); // Green for AI's to-square
    }

    
    function highlightSquare(square, color) {
            const squareElement = document.querySelector(`.square-${square}`);
            if (squareElement) {
                squareElement.style.backgroundColor = color;
            }
        }

        function removeHighlighting() {
            document.querySelectorAll("#board .square-55d63").forEach(square => {
                square.style.backgroundColor = "";
            });
        }

    // Initialize Chessboard with correct event handlers
    board = Chessboard('board', {
        draggable: true,
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        onMouseoverSquare: onMouseoverSquare,
        onMouseoutSquare: onMouseoutSquare
    });

    updateMoveHistory();

    // AI moves first if playing as Black
    if (game.turn() === 'b') {
        setTimeout(makeBestMove, 500);
    }
}



// Stop AI function
function stopAIPlay() {
    stopAI = true;
}

// Add a button to stop AI play
document.addEventListener("DOMContentLoaded", () => {
    const stopBtn = document.createElement("button");
    stopBtn.id = "stopAIBtn";
    stopBtn.innerText = "Stop AI";
    stopBtn.onclick = stopAIPlay;
    document.body.appendChild(stopBtn);
});
       function onMouseoverSquare(square) {
    const moves = game.moves({
        square: square,
        verbose: true
    });

    if (moves.length === 0) return;

    // Highlight selected square
    highlightSquare(square, "rgba(255, 255, 0, 0.6)"); // Yellow highlight

    // Highlight all possible move destinations
    moves.forEach(move => {
        highlightSquare(move.to, "rgba(0, 255, 0, 0.6)"); // Green highlight
    });
}

function onMouseoutSquare(square) {
    removeHighlighting();
}

function highlightSquare(square, color) {
    const squareElement = document.querySelector(`.square-${square}`);
    if (squareElement) {
        squareElement.style.backgroundColor = color;
    }
}

function removeHighlighting() {
    document.querySelectorAll("#board .square-55d63").forEach(square => {
        square.style.backgroundColor = "";
    });
}

        function onSnapEnd() {
            board.position(game.fen());
        }

        async function makeAIMove() {
            if (game.game_over()) return; // Stop if game is over

            const fen = game.fen();
            const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=10`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to get AI move");

                const data = await response.json();
                if (data.success && data.bestmove) {
                    const bestMove = data.bestmove.split(" ")[1]; // Extract best move (e.g., "b7b6")
                    game.move(bestMove);
                    board.position(game.fen());
                    updateMoveHistory();
                    checkGameStatus();
                }
            } catch (error) {
                console.error("Error making AI move:", error);
            }
        }

        function checkGameStatus() {
            const statusElement = document.getElementById("gameStatus");

            if (game.in_checkmate()) {
                let winner = game.turn() === 'w' ? 'Black' : 'White';
                statusElement.innerText = `Checkmate! ${winner} Wins!`;
            } else if (game.in_draw()) {
                statusElement.innerText = "It's a Draw!";
            } else if (game.in_check()) {
                statusElement.innerText = "Check!";
            } else {
                statusElement.innerText = ""; // Clear status if the game continues
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById("move-list");
            moveList.innerHTML = ""; // Clear previous moves

            const history = game.history();
            history.forEach((move, index) => {
                const li = document.createElement("li");
                li.textContent = `${index + 1}. ${move}`;
                moveList.appendChild(li);
            });
        }

        document.getElementById("restartBtn").addEventListener("click", () => {
            game.reset();
            board.position('start');
            document.getElementById("gameStatus").innerText = ""; // Clear status message
            updateMoveHistory();
        });

        function navigateMoves(direction) {
            currentMoveIndex += direction;

            if (currentMoveIndex < 0) currentMoveIndex = 0;
            if (currentMoveIndex > moves.length) currentMoveIndex = moves.length;

            game.reset();
            for (let i = 0; i < currentMoveIndex; i++) {
                game.move(moves[i].san);
            }

            board.position(game.fen());

            // Analyze move with Stockfish
            analyzeCurrentMove();
        }
    </script>
</body>
</html>
