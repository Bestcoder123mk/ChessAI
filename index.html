<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI</title>

    <!-- Local Dependencies -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #e0eafc, #cfdef3);
            color: #333;
            padding: 20px;
        }

        h2 {
            color: #007BFF;
            font-size: 24px;
            margin-bottom: 10px;
        }

        #board-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px auto;
            max-width: 800px;
        }

        #board {
            width: 400px;
            height: 400px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            background-color: #fff;
            padding: 10px;
        }

        #move-history {
            width: 200px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            max-height: 400px;
            overflow-y: auto;
        }

        button {
            padding: 12px 15px;
            margin: 8px;
            border: none;
            background: linear-gradient(90deg, #007BFF, #0056b3);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease-in-out;
        }

        button:hover {
            background: linear-gradient(90deg, #0056b3, #004494);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        input, select {
            padding: 10px;
            margin: 8px;
            border-radius: 6px;
            border: 1px solid #bbb;
            font-size: 14px;
            width: 250px;
            text-align: center;
        }

        #gameStatus {
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
        }

        #gameStatus:empty {
            display: none;
        }

        #info {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: inline-block;
        }

        @media (max-width: 600px) {
            #board-container {
                flex-direction: column;
                align-items: center;
            }

            #board {
                width: 300px;
                height: 300px;
            }

            #move-history {
                width: 100%;
                max-height: 200px;
            }

            button {
                font-size: 14px;
                padding: 10px;
            }

            input, select {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <h2>Chess AI</h2>
    <div id="board-container">
        <div id="board"></div>
        <div id="move-history">
            <h3>Move History</h3>
            <ul id="move-list"></ul>
        </div>
    </div>
    <button id="gamestartBtn">Play With A Computer</button>
    <p id="gameStatus" style="font-size: 18px; font-weight: bold; color: red;"></p>
    <button id="restartBtn">Restart Game</button>
    <button id="startBtn">Start Position</button>
    <button id="clearBtn">Clear Board</button>
    <p id="move-analysis">Move Analysis: -</p>
    <div id="info">
        <button id="bestMoveBtn">Find Best Move</button>
        <p id="best-move">Best Move: -</p>
        <input type="text" id="username" placeholder="Enter Chess.com Username">
        <button onclick="fetchPlayerData()" id="statsBtn">Get Player Stats</button>
        <p id="player-stats">Player Stats: -</p>
        <h3>Past Games</h3>
        <select id="game-history">
            <option value="">Select a game</option>
        </select>
        <button id="analyzeGame">Analyze Game</button>
    </div>


    <script>
        let board, game, moves, currentMoveIndex;
        
        document.addEventListener("DOMContentLoaded", () => {
            game = new Chess();
            board = Chessboard('board', {
                draggable: true,
                position: 'start',
                pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });
        });

        document.getElementById("startBtn").addEventListener("click", () => {
            game.reset();
            board.position('start');
            updateMoveHistory();
        });
        
        document.getElementById("clearBtn").addEventListener("click", () => {
            game.clear();
            board.position('empty');
            updateMoveHistory();
        });

        document.getElementById("bestMoveBtn").addEventListener("click", analyzeWithStockfish);
        document.getElementById("gamestartBtn").addEventListener("click", play);
        
        async function analyzeWithStockfish() {
            const fen = game.fen();
            const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to get analysis");

                const data = await response.json();
                if (data.success && data.bestmove) {
                    const bestMove = data.bestmove.split(" ")[1]; // Extract best move (e.g., "b7b6")

                    if (bestMove.length === 4) {
                        const fromSquare = bestMove.substring(0, 2);
                        const toSquare = bestMove.substring(2, 4);

                        // Highlight squares on the board
                        highlightMove(fromSquare, toSquare);
                    }

                    document.getElementById("best-move").innerText = `Best Move: ${bestMove} (Eval: ${data.evaluation})`;
                } else {
                    document.getElementById("best-move").innerText = "Best Move: No data available";
                }
            } catch (error) {
                console.error("Error analyzing position:", error);
                document.getElementById("best-move").innerText = "Best Move: Error fetching move";
            }
        }

        function highlightMove(from, to) {
            // Remove previous highlights
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));

            // Add new highlights
            document.querySelector(`.square-${from}`).classList.add('highlight');
            document.querySelector(`.square-${to}`).classList.add('highlight');
        }

        const style = document.createElement('style');
        style.innerHTML = `
            .highlight {
                background-color: rgba(255, 215, 0, 0.7) !important; /* Gold color */
            }
        `;
        document.head.appendChild(style);

        async function fetchPlayerData() {
            const username = document.getElementById("username").value.trim();
            if (!username) {
                alert("Please enter a Chess.com username");
                return;
            }
            
            try {
                const statsResponse = await fetch(`https://api.chess.com/pub/player/${username}/stats`);
                if (!statsResponse.ok) throw new Error("Player not found");
                const statsData = await statsResponse.json();

                document.getElementById("player-stats").innerText = 
                    `Blitz: ${statsData.chess_blitz?.last?.rating || "N/A"}, ` +
                    `Bullet: ${statsData.chess_bullet?.last?.rating || "N/A"}, ` +
                    `Rapid: ${statsData.chess_rapid?.last?.rating || "N/A"}`;

                await getPlayerGames(username);
            } catch (error) {
                console.error("Error fetching player data:", error);
                document.getElementById("player-stats").innerText = "Player Stats: Error fetching data";
            }
        }

        async function getPlayerGames(username) {
            try {
                const response = await fetch(`https://api.chess.com/pub/player/${username}/games/archives`);
                if (!response.ok) throw new Error("Games not found");
                const archives = await response.json();
                
                const latestArchiveUrl = archives.archives.pop();
                const gameResponse = await fetch(latestArchiveUrl);
                if (!gameResponse.ok) throw new Error("Games not found");
                const gameData = await gameResponse.json();

                const select = document.getElementById("game-history");
                select.innerHTML = '<option value="">Select a game</option>';
                
                gameData.games.forEach(game => {
                    if (game.pgn) {
                        const option = document.createElement("option");
                        option.value = game.pgn;
                        option.textContent = new Date(game.end_time * 1000).toLocaleString();
                        select.appendChild(option);
                    }
                });
            } catch (error) {
                console.error("Error fetching games:", error);
            }
        }

        document.getElementById("analyzeGame").addEventListener("click", analyzeSelectedGame);

        function analyzeSelectedGame() {
            const selectedGamePGN = document.getElementById("game-history").value;
            if (!selectedGamePGN) {
                alert("Please select a game to analyze!");
                return;
            }

            game.load_pgn(selectedGamePGN);
            moves = game.history({ verbose: true });
            currentMoveIndex = 0;
            board.position(game.fen());

            document.getElementById("best-move").innerText = "Best Move: -";
            createNavigationButtons();
        }

        function createNavigationButtons() {
            let controls = document.getElementById("info");

            if (!document.getElementById("prevMoveBtn")) {
                let prevBtn = document.createElement("button");
                prevBtn.id = "prevMoveBtn";
                prevBtn.innerText = "Previous Move";
                prevBtn.onclick = () => navigateMoves(-1);
                controls.appendChild(prevBtn);
            }

            if (!document.getElementById("nextMoveBtn")) {
                let nextBtn = document.createElement("button");
                nextBtn.id = "nextMoveBtn";
                nextBtn.innerText = "Next Move";
                nextBtn.onclick = () => navigateMoves(1);
                controls.appendChild(nextBtn);
            }
        }

        async function analyzeCurrentMove() {
            const fen = game.fen();
            const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to get analysis");
                
                const data = await response.json();
                if (!data.success || !data.bestmove) {
                    document.getElementById("move-analysis").innerText = "No analysis available";
                    return;
                }

                let bestMove = data.bestmove.trim().split(" ")[0] || "N/A";
                let evalScore = data.evaluation ? parseFloat(data.evaluation) : 0;

                const playerMove = moves[currentMoveIndex - 1]?.san || "None";

                let moveCategory = "Good Move", moveColor = "black";
                if (playerMove === bestMove) {
                    moveCategory = "Best Move"; moveColor = "green";
                } else if (evalScore >= 2.5) {
                    moveCategory = "Brilliant Move"; moveColor = "cyan";
                } else if (evalScore >= 1.5) {
                    moveCategory = "Great Move"; moveColor = "indigo";
                } else if (evalScore >= 0.8) {
                    moveCategory = "Inaccuracy"; moveColor = "#FFCE1B";
                } else if (evalScore >= 3.0) {
                    moveCategory = "Blunder"; moveColor = "red";
                }

                document.getElementById("move-analysis").innerHTML = 
                    `<strong>${moveCategory}:</strong> ${playerMove} <br>
                     Stockfish Suggestion: <strong>${bestMove}</strong> <br> 
                     Eval: <strong>${evalScore}</strong>`;
                document.getElementById("move-analysis").style.color = moveColor;
            } catch (error) {
                console.error("Error analyzing move:", error);
                document.getElementById("move-analysis").innerText = "Error fetching move data";
            }
        }

        function play() { 
            game.reset();
            board.position('start');
            function onDragStart(source, piece, position, orientation) {
        if (game.game_over()) return false;
        if (piece.search(/^b/) !== -1) return false;
    }

    function makeRandomMove() {
        if (game.game_over()) return; // Stop if game is over

        var possibleMoves = game.moves();
        if (possibleMoves.length === 0) return;

        var randomIdx = Math.floor(Math.random() * possibleMoves.length);
        game.move(possibleMoves[randomIdx]);
        board.position(game.fen());

        checkGameStatus();  // ✅ Check after AI move
    }

    function onDrop(source, target) {
        var move = game.move({ from: source, to: target, promotion: 'q' });

        if (move === null) return 'snapback';

        checkGameStatus();  // ✅ Check after player move

        if (!game.game_over()) {
            window.setTimeout(makeRandomMove, 250);
        }
    }

    function onSnapEnd() {
        board.position(game.fen());
    }

    function checkGameStatus() {
        const statusElement = document.getElementById("gameStatus");

        if (game.in_checkmate()) {
            let winner = game.turn() === 'w' ? 'Black' : 'White';
            statusElement.innerText = `Checkmate! ${winner} Wins!`;
        } else if (game.in_draw()) {
            statusElement.innerText = "It's a Draw!";
        } else {
            statusElement.innerText = ""; // Clear status if the game continues
        }
    }

    var config = {
        draggable: true,
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd
    };
    board = Chessboard('board', config);

    document.getElementById("restartBtn").addEventListener("click", () => {
        game.reset();
        board.position('start');
        document.getElementById("gameStatus").innerText = ""; // Clear status message
    });
            updateMoveHistory();
        }

        function removeGreySquares() {
            $('#board .square-55d63').css('background', '');
        }

        function greySquare(square) {
            var $square = $('#board .square-' + square);

            var background = whiteSquareGrey;
            if ($square.hasClass('black-3c85d')) {
                background = blackSquareGrey;
            }

            $square.css('background', background);
        }

        function onDragStart(source, piece) {
            if (game.game_over()) return false;

            if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }

        function onDrop(source, target) {
            removeGreySquares();

            var move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Promote to a queen by default
            });

            if (move === null) return 'snapback';

            board.position(game.fen());
            updateMoveHistory();
            makeAIMove();
            checkGameStatus();
        }

        function onMouseoverSquare(square) {
            var moves = game.moves({
                square: square,
                verbose: true
            });

            if (moves.length === 0) return;

            greySquare(square);

            for (var i = 0; i < moves.length; i++) {
                greySquare(moves[i].to);
            }
        }

        function onMouseoutSquare(square) {
            removeGreySquares();
        }

        function onSnapEnd() {
            board.position(game.fen());
        }

        async function makeAIMove() {
            if (game.game_over()) return; // Stop if game is over

            const fen = game.fen();
            const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=10`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to get AI move");

                const data = await response.json();
                if (data.success && data.bestmove) {
                    const bestMove = data.bestmove.split(" ")[1]; // Extract best move (e.g., "b7b6")
                    game.move(bestMove);
                    board.position(game.fen());
                    updateMoveHistory();
                    checkGameStatus();
                }
            } catch (error) {
                console.error("Error making AI move:", error);
            }
        }

        function checkGameStatus() {
            const statusElement = document.getElementById("gameStatus");

            if (game.in_checkmate()) {
                let winner = game.turn() === 'w' ? 'Black' : 'White';
                statusElement.innerText = `Checkmate! ${winner} Wins!`;
            } else if (game.in_draw()) {
                statusElement.innerText = "It's a Draw!";
            } else if (game.in_check()) {
                statusElement.innerText = "Check!";
            } else {
                statusElement.innerText = ""; // Clear status if the game continues
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById("move-list");
            moveList.innerHTML = ""; // Clear previous moves

            const history = game.history();
            history.forEach((move, index) => {
                const li = document.createElement("li");
                li.textContent = `${index + 1}. ${move}`;
                moveList.appendChild(li);
            });
        }

        document.getElementById("restartBtn").addEventListener("click", () => {
            game.reset();
            board.position('start');
            document.getElementById("gameStatus").innerText = ""; // Clear status message
            updateMoveHistory();
        });

        function navigateMoves(direction) {
            currentMoveIndex += direction;

            if (currentMoveIndex < 0) currentMoveIndex = 0;
            if (currentMoveIndex > moves.length) currentMoveIndex = moves.length;

            game.reset();
            for (let i = 0; i < currentMoveIndex; i++) {
                game.move(moves[i].san);
            }

            board.position(game.fen());

            // Analyze move with Stockfish
            analyzeCurrentMove();
        }
    </script>
</body>
</html>
