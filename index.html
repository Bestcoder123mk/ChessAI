<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI</title>

    <!-- Local Dependencies -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    
    <style>
body {
    font-family: 'Poppins', sans-serif;
    text-align: center;
    background: linear-gradient(135deg, #e0eafc, #cfdef3);
    color: #333;
    padding: 20px;
}

h2 {
    color: #007BFF;
    font-size: 24px;
    margin-bottom: 10px;
}

#board {
    width: 400px;
    height: 400px;
    margin: 20px auto;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    background-color: #fff;
    padding: 10px;
}

button {
    padding: 12px 15px;
    margin: 8px;
    border: none;
    background: linear-gradient(90deg, #007BFF, #0056b3);
    color: white;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.3s ease-in-out;
}

button:hover {
    background: linear-gradient(90deg, #0056b3, #004494);
    transform: scale(1.05);
}

button:active {
    transform: scale(0.95);
}

input, select {
    padding: 10px;
    margin: 8px;
    border-radius: 6px;
    border: 1px solid #bbb;
    font-size: 14px;
    width: 250px;
    text-align: center;
}

#gameStatus {
    font-size: 18px;
    font-weight: bold;
    margin-top: 10px;
    padding: 10px;
    border-radius: 6px;
}

#gameStatus:empty {
    display: none;
}

#info {
    margin-top: 20px;
    padding: 15px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    display: inline-block;
}

@media (max-width: 600px) {
    #board {
        width: 300px;
        height: 300px;
    }

    button {
        font-size: 14px;
        padding: 10px;
    }

    input, select {
        width: 200px;
    }
}
    
    </style>
</head>
<body>
    <h2>Chess AI</h2>
    <div id="board"></div>
    <button id="gamestartBtn">Play With A Computer</button>
    <p id="gameStatus" style="font-size: 18px; font-weight: bold; color: red;"></p>
    <button id="restartBtn">Restart Game</button>
    <button id="startBtn">Start Position</button>
    <button id="clearBtn">Clear Board</button>
    <p id="move-analysis">Move Analysis: -</p>
    <div id="info">
        <button id="bestMoveBtn">Find Best Move</button>
        <p id="best-move">Best Move: -</p>
        <input type="text" id="username" placeholder="Enter Chess.com Username">
        <button onclick="fetchPlayerData()" id="statsBtn">Get Player Stats</button>
        <p id="player-stats">Player Stats: -</p>
        <h3>Past Games</h3>
        <select id="game-history">
            <option value="">Select a game</option>
        </select>
        <button id="analyzeGame">Analyze Game</button>
    </div>

    <script>
        let board, game, moves, currentMoveIndex;
        
        document.addEventListener("DOMContentLoaded", () => {
            game = new Chess();
            board = Chessboard('board', {
                draggable: true,
                position: 'start',
                pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
            });
        });

        document.getElementById("startBtn").addEventListener("click", () => {
            game.reset();
            board.position('start');
        });
        
        document.getElementById("clearBtn").addEventListener("click", () => {
            game.clear();
            board.position('empty');
        });

        document.getElementById("bestMoveBtn").addEventListener("click", analyzeWithStockfish);
        document.getElementById("gamestartBtn").addEventListener("click", play);
        
        async function analyzeWithStockfish() {
    const fen = game.fen();  // Get current board position in FEN format
    const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

    console.log("Sending request to Stockfish API:", url); // Debugging log

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to get analysis");

        const data = await response.json();
        console.log("Stockfish API Response:", data);  // Debugging log

        if (data.success && data.bestmove) {
            // Extract best move from the response
            const bestMove = data.bestmove.split(" ")[1]; // Extract move (e.g., "b7b6")
            document.getElementById("best-move").innerText = `Best Move: ${bestMove} (Eval: ${data.evaluation})`;
        } else {
            document.getElementById("best-move").innerText = "Best Move: No data available";
        }
    } catch (error) {
        console.error("Error analyzing position:", error);
        document.getElementById("best-move").innerText = "Best Move: Error fetching move";
    }
}




        async function fetchPlayerData() {
            const username = document.getElementById("username").value.trim();
            if (!username) {
                alert("Please enter a Chess.com username");
                return;
            }
            
            try {
                const statsResponse = await fetch(`https://api.chess.com/pub/player/${username}/stats`);
                if (!statsResponse.ok) throw new Error("Player not found");
                const statsData = await statsResponse.json();

                document.getElementById("player-stats").innerText = 
                    `Blitz: ${statsData.chess_blitz?.last?.rating || "N/A"}, ` +
                    `Bullet: ${statsData.chess_bullet?.last?.rating || "N/A"}, ` +
                    `Rapid: ${statsData.chess_rapid?.last?.rating || "N/A"}`;

                await getPlayerGames(username);
            } catch (error) {
                console.error("Error fetching player data:", error);
                document.getElementById("player-stats").innerText = "Player Stats: Error fetching data";
            }
        }

        async function getPlayerGames(username) {
            try {
                const response = await fetch(`https://api.chess.com/pub/player/${username}/games/archives`);
                if (!response.ok) throw new Error("Games not found");
                const archives = await response.json();
                
                const latestArchiveUrl = archives.archives.pop();
                const gameResponse = await fetch(latestArchiveUrl);
                if (!gameResponse.ok) throw new Error("Games not found");
                const gameData = await gameResponse.json();

                const select = document.getElementById("game-history");
                select.innerHTML = '<option value="">Select a game</option>';
                
                gameData.games.forEach(game => {
                    if (game.pgn) {
                        const option = document.createElement("option");
                        option.value = game.pgn;
                        option.textContent = new Date(game.end_time * 1000).toLocaleString();
                        select.appendChild(option);
                    }
                });
            } catch (error) {
                console.error("Error fetching games:", error);
            }
        }
        document.getElementById("analyzeGame").addEventListener("click", analyzeSelectedGame);

    function analyzeSelectedGame() {
        const selectedGamePGN = document.getElementById("game-history").value;
        if (!selectedGamePGN) {
            alert("Please select a game to analyze!");
            return;
        }

        game.load_pgn(selectedGamePGN);
        moves = game.history({ verbose: true });
        currentMoveIndex = 0;
        board.position(game.fen());

        document.getElementById("best-move").innerText = "Best Move: -";
        createNavigationButtons();
    }

    function createNavigationButtons() {
        let controls = document.getElementById("info");

        if (!document.getElementById("prevMoveBtn")) {
            let prevBtn = document.createElement("button");
            prevBtn.id = "prevMoveBtn";
            prevBtn.innerText = "Previous Move";
            prevBtn.onclick = () => navigateMoves(-1);
            controls.appendChild(prevBtn);
        }

        if (!document.getElementById("nextMoveBtn")) {
            let nextBtn = document.createElement("button");
            nextBtn.id = "nextMoveBtn";
            nextBtn.innerText = "Next Move";
            nextBtn.onclick = () => navigateMoves(1);
            controls.appendChild(nextBtn);
        }
    }

    async function analyzeCurrentMove() {
    const fen = game.fen();
    const url = `https://stockfish.online/api/s/v2.php?fen=${encodeURIComponent(fen)}&depth=15`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to get analysis");

        const data = await response.json();
        console.log("Stockfish API Response:", data);  // ðŸ”¥ Debugging: See the full response

        if (!data.success || !data.bestmove) {
            console.error("Stockfish did not return a valid best move.");
            document.getElementById("move-analysis").innerText = "No analysis available";
            return;
        }

        const bestMove = data.bestmove.split(" ")[1] || "N/A";  // Extract Stockfish's best move
        const evalScore = parseFloat(data.evaluation || "0");  // Ensure evaluation is a number

        console.log(`Best Move: ${bestMove}, Evaluation: ${evalScore}`);  // Debugging logs

        // Get the player's move
        const playerMove = moves[currentMoveIndex - 1]?.san || "None";

        let moveCategory = "Good Move"; // Default label
        let moveColor = "black"; // Default color

        // Chess.com-style Move Categorization
        const evalThresholds = {
            brilliant: 2.5,  // Sacrifice & best move
            great: 2.0,  // Best move but not a sacrifice
            book: 0.0,   // Opening moves
            inaccuracy: 0.8,  // Small mistake
            mistake: 1.5, // Medium mistake
            blunder: 3.0  // Huge mistake
        };

        if (playerMove === bestMove) {
            moveCategory = "Best Move";
            moveColor = "green";
        } 
        else if (Math.abs(evalScore) <= evalThresholds.book) {
            moveCategory = "Book Move";
            moveColor = "gray";
        } 
        else if (Math.abs(evalScore) > evalThresholds.brilliant && playerMove !== bestMove) {
            moveCategory = "Brilliant Move";
            moveColor = "cyan";
        } 
        else if (Math.abs(evalScore) > evalThresholds.great && playerMove !== bestMove) {
            moveCategory = "Great Move";
            moveColor = "indigo";
        } 
        else if (Math.abs(evalScore) > evalThresholds.inaccuracy && Math.abs(evalScore) < evalThresholds.mistake) {
            moveCategory = "Inaccuracy";
            moveColor = "#FFCE1B";
        } 
        else if (Math.abs(evalScore) > evalThresholds.mistake && Math.abs(evalScore) < evalThresholds.blunder) {
            moveCategory = "Mistake";
            moveColor = "orange";
        } 
        else if (Math.abs(evalScore) > evalThresholds.blunder) {
            moveCategory = "Blunder";
            moveColor = "red";
        }

        // Display Move Analysis
        const moveInfo = document.getElementById("move-analysis");
        moveInfo.innerHTML = `<strong>${moveCategory}:</strong> ${playerMove} <br> 
                              Stockfish Suggestion: <strong>${bestMove}</strong> <br> 
                              Eval: <strong>${evalScore}</strong>`;
        moveInfo.style.color = moveColor;

    } catch (error) {
        console.error("Error analyzing position:", error);
        document.getElementById("move-analysis").innerText = "Error fetching move data";
    }
}
function play() {   
    board = null;
    game = new Chess();

    function onDragStart(source, piece, position, orientation) {
        if (game.game_over()) return false;
        if (piece.search(/^b/) !== -1) return false;
    }
    function makeRandomMove() {
        if (game.game_over()) return; // Stop if game is over

        var possibleMoves = game.moves();
        if (possibleMoves.length === 0) return;

        var randomIdx = Math.floor(Math.random() * possibleMoves.length);
        game.move(possibleMoves[randomIdx]);
        board.position(game.fen());

        checkGameStatus();  
    }
    function makeBestMove() {
    if (game.game_over()) return; // Stop if game is over

    let stockfish = new Worker("stockfish.js"); // Initialize Stockfish engine

    stockfish.postMessage("position fen " + game.fen()); // Set the board position
    stockfish.postMessage("go depth 15"); // Ask for the best move with a depth of 15

    stockfish.onmessage = function (event) {
        let message = event.data;
        
        if (message.startsWith("bestmove")) {
            let bestMove = message.split(" ")[1]; // Extract the best move
            game.move({ from: bestMove.substring(0, 2), to: bestMove.substring(2, 4), promotion: 'q' });
            
            board.position(game.fen()); // Update the board
            checkGameStatus(); // Check if the game is over
            
            stockfish.terminate(); // Stop Stockfish
        }
    };
}

    function onDrop(source, target) {
        var move = game.move({ from: source, to: target, promotion: 'q' });
        if (move === null) return 'snapback';

        checkGameStatus();  

        if (!game.game_over()) {
        var pickBestMove = Math.random() < 0.5; 

        window.setTimeout(pickBestMove ? makeBestMove : makeRandomMove, 250);
    }
}

    function onSnapEnd() {
        board.position(game.fen());
    }

    function checkGameStatus() {
        const statusElement = document.getElementById("gameStatus");

        if (game.in_checkmate()) {
            let winner = game.turn() === 'w' ? 'Black' : 'White';
            statusElement.innerText = `Checkmate! ${winner} Wins!`;
        } else if (game.in_draw()) {
            statusElement.innerText = "It's a Draw!";
        } else {
            statusElement.innerText = ""; // Clear status if the game continues
        }
    }

    var config = {
        draggable: true,
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd
    };
    board = Chessboard('board', config);

    document.getElementById("restartBtn").addEventListener("click", () => {
        game.reset();
        board.position('start');
        document.getElementById("gameStatus").innerText = ""; // Clear status message
    });
    const stopButton = document.createElement("button");
stopButton.innerText = "Stop Playing";
stopButton.onclick = stopComputerPlay;
document.body.appendChild(stopButton);
}

    

// Modify `navigateMoves()` to analyze each move
function navigateMoves(direction) {
    currentMoveIndex += direction;

    if (currentMoveIndex < 0) currentMoveIndex = 0;
    if (currentMoveIndex > moves.length) currentMoveIndex = moves.length;

    game.reset();
    for (let i = 0; i < currentMoveIndex; i++) {
        game.move(moves[i].san);
    }

    board.position(game.fen());

    // Analyze move with Stockfish
    analyzeCurrentMove();
}

    </script>
</body>
</html>
